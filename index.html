<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sens Private - Secure Messenger</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Core -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Compiler -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        html, body, #root {
            height: 100%; height: 100dvh;
            margin: 0; padding: 0;
            overflow: hidden;
            background-color: #f8fafc;
            width: 100vw;
        }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .typing-dot {
            display: inline-block;
            width: 4px; height: 4px; border-radius: 50%;
            background-color: currentColor;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-4px); opacity: 1; }
        }
        .message-group .reply-button { opacity: 0; transition: opacity 0.2s; }
        .message-group:hover .reply-button { opacity: 1; }
        @media (max-width: 768px) { .message-group .reply-button { opacity: 1; } }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .emoji-scroll::-webkit-scrollbar { width: 4px; }
        .emoji-scroll::-webkit-scrollbar-thumb { background: #e2e8f0; border-radius: 10px; }
        #localVideo { transform: scaleX(-1); border-radius: 1rem; }
        .fade-in { animation: fadeIn 0.2s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .msg-bubble {
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
        }
    </style>
</head>
<body class="bg-slate-50 font-sans text-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, updateDoc, getDoc, setDoc, writeBatch, getDocs, where, deleteDoc } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";

        const firebaseConfig = typeof __firebase_config !== 'undefined' 
            ? JSON.parse(__firebase_config) 
            : {
                apiKey: "AIzaSyACttfdN58V6wmpTbqRaHIgc_Swo5s4L-U",
                authDomain: "sens-1129c.firebaseapp.com",
                projectId: "sens-1129c",
                storageBucket: "sens-1129c.firebasestorage.app",
                messagingSenderId: "578023720878",
                appId: "1:578023720878:web:1f25be43855a6409f0aa3f"
            };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'sens-chat';

        const USERS_PATH = ['artifacts', appId, 'public', 'data', 'users'];
        const MSGS_PATH = ['artifacts', appId, 'public', 'data', 'messages'];
        const CALLS_PATH = ['artifacts', appId, 'public', 'data', 'calls'];

        const EMOJI_LIST = ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ˜', 'ðŸ¥³', 'ðŸ˜Ž', 'ðŸ¤”', 'ðŸ‘', 'ðŸ”¥', 'â¤ï¸', 'âœ¨', 'ðŸŽ‰', 'ðŸ™', 'ðŸ’¯', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ˜¢', 'ðŸ˜®', 'âœ…', 'âŒ', 'ðŸš€', 'â­', 'ðŸŽˆ', 'ðŸŽ', 'ðŸ’¡', 'ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––', 'ðŸ‘Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸', 'ðŸ‘', 'ðŸ‘Ž', 'âœŠ', 'ðŸ‘Š', 'ðŸ¤›', 'ðŸ¤œ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ‘', 'ðŸ¤²', 'ðŸ¤', 'ðŸ™'];

        const Icon = ({ name, className, size = 20 }) => {
            const iconRef = React.useRef(null);
            React.useEffect(() => {
                if (window.lucide && iconRef.current) {
                    const temp = document.createElement('div');
                    temp.innerHTML = `<i data-lucide="${name}"></i>`;
                    window.lucide.createIcons({ root: temp });
                    const svg = temp.querySelector('svg');
                    if (svg) {
                        svg.setAttribute('class', className || '');
                        svg.setAttribute('width', size);
                        svg.setAttribute('height', size);
                        iconRef.current.innerHTML = '';
                        iconRef.current.appendChild(svg);
                    }
                }
            }, [name, className, size]);
            return <span ref={iconRef} className="inline-flex items-center justify-center leading-none" />;
        };

        function App() {
            const [user, setUser] = React.useState(null);
            const [profile, setProfile] = React.useState(null);
            const [messages, setMessages] = React.useState([]);
            const [allUsers, setAllUsers] = React.useState([]);
            const [selectedUser, setSelectedUser] = React.useState(null);
            const [usernameInput, setUsernameInput] = React.useState('');
            const [passwordInput, setPasswordInput] = React.useState('');
            const [newMessage, setNewMessage] = React.useState('');
            const [loading, setLoading] = React.useState(true);
            const [authError, setAuthError] = React.useState('');
            const [replyingTo, setReplyingTo] = React.useState(null);
            const [showConfirmClear, setShowConfirmClear] = React.useState(false);
            const [isClearing, setIsClearing] = React.useState(false);
            const [showEmojiPicker, setShowEmojiPicker] = React.useState(false);
            
            const [isCalling, setIsCalling] = React.useState(false);
            const [incomingCall, setIncomingCall] = React.useState(null);
            const [localStream, setLocalStream] = React.useState(null);
            const [remoteStream, setRemoteStream] = React.useState(null);
            
            const pc = React.useRef(null);
            const scrollRef = React.useRef(null);
            const inputRef = React.useRef(null);

            const getChatId = (u1, u2) => [u1.toLowerCase(), u2.toLowerCase()].sort().join('_');

            // 1. Auth & Session Management
            React.useEffect(() => {
                const initAuth = async () => { 
                    try { 
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else { await signInAnonymously(auth); }
                    } catch (e) { setLoading(false); } 
                };
                initAuth();
                return onAuthStateChanged(auth, (u) => {
                    if (u) {
                        setUser(u);
                        onSnapshot(collection(db, ...USERS_PATH), (snapshot) => {
                            const found = snapshot.docs.find(d => d.data().uid === u.uid);
                            if (found) setProfile(found.data());
                            else setProfile({ status: 'new' });
                            setLoading(false);
                        });
                    } else { setUser(null); setProfile(null); setLoading(false); }
                });
            }, []);

            // 2. Video Call Signaling & ICE Candidates
            React.useEffect(() => {
                if (!profile?.username || !user) return;
                const callsRef = collection(db, ...CALLS_PATH);
                return onSnapshot(callsRef, (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        const data = change.doc.data();
                        if (change.type === 'added' && data.target === profile.username && data.status === 'offered') {
                            setIncomingCall({ id: change.doc.id, ...data });
                        }
                        if (data.status === 'ended' && (data.target === profile.username || data.caller === profile.username)) {
                            endCallLocally();
                        }
                    });
                });
            }, [profile, user]);

            // 3. Sync Logic (Users & Messages)
            React.useEffect(() => {
                if (!user || (profile?.status !== 'approved' && profile?.role !== 'admin')) return;
                return onSnapshot(collection(db, ...USERS_PATH), (snapshot) => {
                    setAllUsers(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                });
            }, [user, profile]);

            React.useEffect(() => {
                if (!user || !selectedUser || !profile?.username) return;
                const currentChatId = getChatId(profile.username, selectedUser.username);
                return onSnapshot(collection(db, ...MSGS_PATH), (snapshot) => {
                    const all = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    const filtered = all.filter(m => m.chatId === currentChatId);
                    setMessages(filtered.sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0)).slice(-100));
                });
            }, [user, profile, selectedUser]);

            // 4. Mark messages as read automatically
            React.useEffect(() => {
                if (!user || !selectedUser || messages.length === 0) return;
                messages.filter(m => m.senderName === selectedUser.username && !m.read).forEach(async (m) => {
                    try { await updateDoc(doc(db, ...MSGS_PATH, m.id), { read: true }); } catch (e) {}
                });
            }, [messages, selectedUser]);

            // 5. Scroll & Focus Logic
            React.useEffect(() => { scrollRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);
            React.useEffect(() => { if (replyingTo) inputRef.current?.focus(); }, [replyingTo]);

            // --- VIDEO CALL LOGIC WITH ICE CANDIDATES ---
            const startCall = async () => {
                if (!selectedUser || !user) return;
                try {
                    setIsCalling(true);
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    setLocalStream(stream);
                    pc.current = new RTCPeerConnection({ iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] });
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    pc.current.ontrack = (e) => setRemoteStream(e.streams[0]);

                    const callDoc = doc(collection(db, ...CALLS_PATH));
                    pc.current.onicecandidate = (e) => {
                        if (e.candidate) addDoc(collection(db, ...CALLS_PATH, callDoc.id, 'candidates'), e.candidate.toJSON());
                    };

                    const offer = await pc.current.createOffer();
                    await pc.current.setLocalDescription(offer);
                    await setDoc(callDoc, { caller: profile.username, target: selectedUser.username, offer: { sdp: offer.sdp, type: offer.type }, status: 'offered' });

                    onSnapshot(callDoc, (snap) => {
                        const data = snap.data();
                        if (!pc.current.currentRemoteDescription && data?.answer) pc.current.setRemoteDescription(new RTCSessionDescription(data.answer));
                    });
                    onSnapshot(collection(db, ...CALLS_PATH, callDoc.id, 'candidates'), (snap) => {
                        snap.docChanges().forEach(change => {
                            if (change.type === 'added') pc.current.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                        });
                    });
                } catch (e) { setIsCalling(false); }
            };

            const acceptCall = async () => {
                const callData = incomingCall; setIncomingCall(null); setIsCalling(true);
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    setLocalStream(stream);
                    pc.current = new RTCPeerConnection({ iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] });
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    pc.current.ontrack = (e) => setRemoteStream(e.streams[0]);
                    pc.current.onicecandidate = (e) => {
                        if (e.candidate) addDoc(collection(db, ...CALLS_PATH, callData.id, 'candidates'), e.candidate.toJSON());
                    };
                    await pc.current.setRemoteDescription(new RTCSessionDescription(callData.offer));
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    await updateDoc(doc(db, ...CALLS_PATH, callData.id), { answer: { sdp: answer.sdp, type: answer.type }, status: 'answered' });
                    onSnapshot(collection(db, ...CALLS_PATH, callData.id, 'candidates'), (snap) => {
                        snap.docChanges().forEach(change => {
                            if (change.type === 'added') pc.current.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                        });
                    });
                } catch (e) { setIsCalling(false); }
            };

            const endCall = async () => {
                const snap = await getDocs(collection(db, ...CALLS_PATH));
                snap.forEach(async d => { if (d.data().caller === profile.username || d.data().target === profile.username) await updateDoc(d.ref, { status: 'ended' }); });
                endCallLocally();
            };

            const endCallLocally = () => {
                if (localStream) localStream.getTracks().forEach(t => t.stop());
                if (pc.current) pc.current.close();
                setLocalStream(null); setRemoteStream(null); setIsCalling(false); setIncomingCall(null);
            };

            const handleLogin = async (e) => {
                e.preventDefault();
                const cleanU = usernameInput.trim().toLowerCase();
                const pass = passwordInput.trim();
                setLoading(true);
                try {
                    const userRef = doc(db, ...USERS_PATH, cleanU);
                    const userDoc = await getDoc(userRef);
                    if (userDoc.exists()) {
                        if (userDoc.data().password === pass) await updateDoc(userRef, { uid: user.uid });
                        else setAuthError('Incorrect password.');
                    } else await setDoc(userRef, { username: usernameInput.trim(), password: pass, status: 'pending', createdAt: serverTimestamp(), role: 'member', uid: user.uid, isTyping: false });
                } catch (err) { setAuthError('Connection error.'); }
                setLoading(false);
            };

            const handleSend = async (e) => {
                e.preventDefault();
                if (!newMessage.trim() || !user || !selectedUser) return;
                const text = newMessage; setNewMessage(''); setReplyingTo(null);
                try {
                    const msg = { text, senderName: profile.username, chatId: getChatId(profile.username, selectedUser.username), displayName: profile.username, createdAt: serverTimestamp(), read: false };
                    if (replyingTo) msg.replyTo = { text: replyingTo.text, displayName: replyingTo.displayName };
                    await addDoc(collection(db, ...MSGS_PATH), msg);
                    updateDoc(doc(db, ...USERS_PATH, profile.username.toLowerCase()), { isTyping: false });
                } catch (e) { setNewMessage(text); }
            };

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-600"><div className="animate-spin h-8 w-8 border-4 border-indigo-600 border-t-transparent rounded-full"></div></div>;

            if (!user || profile?.status === 'new') return (
                <div className="h-full flex items-center justify-center p-4 bg-slate-100"><div className="bg-white p-8 rounded-3xl shadow-xl max-w-sm w-full text-center">
                    <Icon name="shield-check" size={48} className="mx-auto mb-4 text-indigo-600" />
                    <h2 className="text-2xl font-bold mb-6">Sens Chat</h2>
                    <form onSubmit={handleLogin} className="space-y-4 text-left">
                        <input className="w-full bg-slate-50 border p-4 rounded-xl outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Username" value={usernameInput} onChange={e => setUsernameInput(e.target.value)} required />
                        <input type="password" className="w-full bg-slate-50 border p-4 rounded-xl outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Password" value={passwordInput} onChange={e => setPasswordInput(e.target.value)} required />
                        {authError && <p className="text-red-500 text-xs font-bold">{authError}</p>}
                        <button className="w-full bg-indigo-600 text-white font-bold py-4 rounded-xl">Connect</button>
                    </form>
                </div></div>
            );

            if (profile?.status === 'pending') return <div className="h-full flex items-center justify-center p-4 text-center"><div className="max-w-xs"><Icon name="clock" size={48} className="mx-auto mb-4 text-amber-500 animate-pulse" /><h2 className="text-xl font-bold">Access Pending</h2><p className="text-slate-500 text-sm mt-2">Wait for admin to verify @{profile.username}.</p></div></div>;

            return (
                <div className="flex h-full w-full max-w-6xl mx-auto bg-white relative overflow-hidden md:flex-row border-x border-slate-100">
                    {/* Video Call Overlays */}
                    {(isCalling || incomingCall) && (
                        <div className="fixed inset-0 z-[100] bg-black/95 backdrop-blur-xl flex flex-col items-center justify-center">
                            {incomingCall ? (
                                <div className="text-white text-center animate-in fade-in">
                                    <div className="w-20 h-20 bg-green-500/20 rounded-full flex items-center justify-center mx-auto mb-6 animate-bounce"><Icon name="phone-incoming" size={32} className="text-green-400" /></div>
                                    <h3 className="text-2xl font-bold mb-8">@{incomingCall.caller} Calling...</h3>
                                    <div className="flex gap-4"><button onClick={acceptCall} className="bg-green-500 px-10 py-4 rounded-2xl font-bold">Accept</button><button onClick={endCall} className="bg-red-500 px-10 py-4 rounded-2xl font-bold">Decline</button></div>
                                </div>
                            ) : (
                                <div className="w-full h-full relative">
                                    <video autoPlay playsInline className="w-full h-full object-cover" ref={v => { if(v && remoteStream) v.srcObject = remoteStream; }} />
                                    <video id="localVideo" autoPlay muted playsInline className="absolute top-4 right-4 w-32 h-48 object-cover border-2 border-white/20 shadow-2xl" ref={v => { if(v && localStream) v.srcObject = localStream; }} />
                                    <div className="absolute bottom-10 left-1/2 -translate-x-1/2"><button onClick={endCall} className="w-16 h-16 bg-red-500 rounded-full flex items-center justify-center text-white"><Icon name="phone-off" size={28} /></button></div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Sidebar */}
                    <div className={`w-full md:w-80 border-r bg-slate-50 flex flex-col shrink-0 h-full ${selectedUser ? 'hidden md:flex' : 'flex'}`}>
                        <header className="p-4 md:p-5 bg-indigo-900 text-white flex items-center justify-between shrink-0 h-16">
                            <div className="flex items-center gap-2"><Icon name="message-square" className="text-indigo-300" /><h2 className="font-bold text-sm tracking-widest uppercase">Messenger</h2></div>
                            <button onClick={() => updateDoc(doc(db, ...USERS_PATH, profile.username.toLowerCase()), { uid: null }).then(() => setUser(null))}><Icon name="log-out" size={18} /></button>
                        </header>
                        <div className="flex-1 overflow-y-auto p-2 hide-scrollbar">
                            {allUsers.filter(u => profile.role === 'admin' ? u.status === 'pending' : false).map(u => (
                                <div key={u.username} className="p-3 bg-white border rounded-xl mb-2"><p className="font-bold text-sm mb-2 uppercase">@{u.username}</p><div className="flex gap-2"><button onClick={() => updateDoc(doc(db, ...USERS_PATH, u.username.toLowerCase()), {status:'approved'})} className="flex-1 bg-indigo-600 text-white py-2 rounded-lg text-[10px] font-bold">APPROVE</button></div></div>
                            ))}
                            <div className="px-3 py-2 text-[10px] font-black uppercase text-slate-400 mt-2">Channels</div>
                            {allUsers.filter(u => u.status === 'approved' && (profile.role === 'admin' ? u.role !== 'admin' : u.role === 'admin')).map(u => (
                                <button key={u.username} onClick={() => setSelectedUser(u)} className={`w-full text-left p-4 rounded-2xl mb-1 flex items-center justify-between group ${selectedUser?.username === u.username ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-indigo-100/50'}`}>
                                    <div className="flex items-center gap-3"><div className={`w-10 h-10 rounded-full flex items-center justify-center font-bold uppercase ${selectedUser?.username === u.username ? 'bg-indigo-500' : 'bg-indigo-100 text-indigo-600'}`}>{u.username[0]}</div><span className="font-bold text-sm uppercase">@{u.username}</span></div>
                                    {u.isTyping && <span className="text-[9px] font-bold animate-pulse uppercase">typing...</span>}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Chat Area */}
                    <div className={`flex-1 flex flex-col bg-white relative h-full min-w-0 ${selectedUser ? 'flex' : 'hidden md:flex'}`}>
                        {selectedUser ? (
                            <div className="flex flex-col h-full fade-in min-w-0">
                                <header className="p-3 md:p-4 border-b flex justify-between items-center bg-white shrink-0 h-16 z-10">
                                    <div className="flex items-center gap-2 min-w-0">
                                        <button onClick={() => setSelectedUser(null)} className="md:hidden p-2"><Icon name="chevron-left" size={24} /></button>
                                        <div className="w-9 h-9 md:w-10 md:h-10 rounded-full bg-slate-100 flex items-center justify-center font-bold uppercase shrink-0 text-slate-400">{selectedUser.username[0]}</div>
                                        <div className="flex flex-col min-w-0"><h2 className="font-bold uppercase text-sm tracking-tight truncate">@{selectedUser.username}</h2><div className="flex items-center gap-1"><div className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></div><span className="text-[9px] font-bold text-indigo-600 uppercase">Secure</span></div></div>
                                    </div>
                                    <div className="flex gap-1"><button onClick={startCall} className="p-2 text-indigo-600"><Icon name="video" size={20} /></button><button onClick={() => setShowConfirmClear(true)} className="p-2 text-slate-300 hover:text-red-500"><Icon name="trash-2" size={20} /></button></div>
                                </header>
                                <main className="flex-1 overflow-y-auto p-4 space-y-4 bg-slate-50/30 hide-scrollbar">
                                    {messages.map(m => (
                                        <div key={m.id} className={`flex ${m.senderName === profile.username ? 'justify-end' : 'justify-start'} group items-center gap-2 max-w-full`}>
                                            <button onClick={() => setReplyingTo(m)} className="reply-button p-2 text-slate-400 bg-white border rounded-full order-last shadow-sm shrink-0"><Icon name="corner-up-left" size={12} /></button>
                                            <div className={`flex flex-col min-w-0 ${m.senderName === profile.username ? 'items-end' : 'items-start'} max-w-[85%] md:max-w-[75%]`}>
                                                <div className={`p-4 rounded-2xl text-[15px] shadow-sm relative msg-bubble ${m.senderName === profile.username ? 'bg-indigo-600 text-white rounded-tr-none' : 'bg-white border text-slate-800 rounded-tl-none'}`}>
                                                    {m.replyTo && <div className={`mb-2 p-2 text-[10px] rounded-lg border-l-4 font-bold ${m.senderName === profile.username ? 'bg-indigo-700/50 text-indigo-100' : 'bg-slate-100 text-slate-500'} italic truncate`}>Reply: {m.replyTo.text}</div>}
                                                    <div className="break-words">{m.text}</div>
                                                </div>
                                                {m.senderName === profile.username && <div className="flex items-center gap-1 mt-1.5 px-2"><span className={`text-[9px] font-black uppercase ${m.read ? 'text-indigo-500' : 'text-slate-300'}`}>{m.read ? 'Seen' : 'Sent'}</span><Icon name={m.read ? "check-check" : "check"} size={10} className={m.read ? "text-indigo-500" : "text-slate-300"} /></div>}
                                            </div>
                                        </div>
                                    ))}
                                    <div ref={scrollRef} className="h-4" />
                                </main>
                                <footer className="p-3 md:p-4 border-t bg-white relative pb-safe">
                                    {showEmojiPicker && <div className="fixed md:absolute bottom-20 left-2 right-2 md:bottom-full md:left-4 md:right-auto mb-2 bg-white border border-slate-200 p-3 rounded-2xl shadow-2xl z-50 h-64 w-auto md:w-64 grid grid-cols-7 md:grid-cols-6 gap-2 overflow-y-auto emoji-scroll">{EMOJI_LIST.map(emoji => <button key={emoji} onClick={() => addEmoji(emoji)} className="p-1 text-2xl active:scale-90">{emoji}</button>)}</div>}
                                    {replyingTo && <div className="mb-3 p-3 bg-slate-50 border-l-4 border-indigo-600 rounded-xl flex items-center justify-between"><div className="flex-1 truncate pr-4 text-[10px] font-bold text-slate-600 uppercase tracking-widest">Replying to {replyingTo.displayName}</div><button onClick={() => setReplyingTo(null)} className="text-slate-400 p-2"><Icon name="x" size={16} /></button></div>}
                                    <form onSubmit={handleSend} className="flex gap-2 w-full items-center">
                                        <button type="button" onClick={() => setShowEmojiPicker(!showEmojiPicker)} className="p-3 shrink-0"><Icon name="smile" size={24} className="text-slate-400" /></button>
                                        <input ref={inputRef} value={newMessage} onFocus={() => setShowEmojiPicker(false)} onChange={(e) => { setNewMessage(e.target.value); updateDoc(doc(db, ...USERS_PATH, profile.username.toLowerCase()), { isTyping: e.target.value.length > 0 }); }} className="flex-1 bg-slate-50 border rounded-2xl px-4 py-3 outline-none focus:ring-2 focus:ring-indigo-500 text-base min-w-0" placeholder="Message..." />
                                        <button type="submit" disabled={!newMessage.trim()} className="bg-indigo-600 text-white p-3 rounded-2xl shadow-lg active:scale-90 disabled:opacity-50 shrink-0"><Icon name="send" className="text-white" size={22} /></button>
                                    </form>
                                </footer>
                            </div>
                        ) : <div className="flex-1 flex flex-col items-center justify-center text-slate-300 p-8 text-center uppercase tracking-[0.2em] font-black"><Icon name="message-square" size={64} className="mb-4 opacity-10" /><p className="text-xs">Secure Vault Tunnel</p></div>}
                    </div>
                </div>
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
